// Generated by delombok at Mon May 27 20:39:51 CEST 2013
package org.um.feri.ears.statistic.true_skill;

import java.util.Collection;

import static java.lang.Math.pow;

/** Container for a player's rating. **/

public class Rating {
	private static final int defaultConservativeStandardDeviationMultiplier = 3;
	private final double conservativeStandardDeviationMultiplier;
	/** The statistical mean value of the rating (also known as μ). **/
	private final double mean;
	/** The standard deviation (the spread) of the rating. This is also known as σ. **/
	private final double standardDeviation;

	/** The variance of the rating (standard deviation squared) **/
	public double getVariance() {
		return pow(getStandardDeviation(), 2);
	}

	/** A conservative estimate of skill based on the mean and standard deviation. **/
	private final double conservativeRating;

	/**
	 * Constructs a rating.
	 * @param mean The statistical mean value of the rating (also known as μ).
	 * @param standardDeviation The standard deviation of the rating (also known as σ).
	 */
	public Rating(double mean, double standardDeviation) {
		this(mean, standardDeviation, defaultConservativeStandardDeviationMultiplier);
	}

	/**
	 * Constructs a rating.
	 * @param mean The statistical mean value of the rating (also known as μ).
	 * @param standardDeviation The number of standardDeviation to subtract from the mean to achieve a conservative
	 * rating.
	 * @param conservativeStandardDeviationMultiplier The number of standardDeviations to subtract from the mean to
	 * achieve a conservative rating.
	 */
	public Rating(double mean, double standardDeviation, double conservativeStandardDeviationMultiplier) {

		this.mean = mean;
		this.standardDeviation = standardDeviation;
		this.conservativeStandardDeviationMultiplier = conservativeStandardDeviationMultiplier;
		this.conservativeRating = mean - conservativeStandardDeviationMultiplier * standardDeviation;
	}

	public static Rating partialUpdate(Rating prior, Rating fullPosterior, double updatePercentage) {
		GaussianDistribution priorGaussian = new GaussianDistribution(prior);
		GaussianDistribution posteriorGaussian = new GaussianDistribution(fullPosterior);
		// From a clarification email from Ralf Herbrich:
		// "the idea is to compute a linear interpolation between the prior and
		// posterior skills of each player ... in the canonical space of
		// parameters"
		double precisionDifference = posteriorGaussian.getPrecision() - priorGaussian.getPrecision();
		double partialPrecisionDifference = updatePercentage * precisionDifference;
		double precisionMeanDifference = posteriorGaussian.getPrecisionMean() - priorGaussian.getPrecisionMean();
		double partialPrecisionMeanDifference = updatePercentage * precisionMeanDifference;
		GaussianDistribution partialPosteriorGaussion = GaussianDistribution.fromPrecisionMean(
				priorGaussian.getPrecisionMean() + partialPrecisionMeanDifference, priorGaussian.getPrecision()
						+ partialPrecisionDifference);
		return new Rating(partialPosteriorGaussion.getMean(), partialPosteriorGaussion.getStandardDeviation(),
				prior.getConservativeStandardDeviationMultiplier());
	}

	@Override
	public String toString() {
		// As a debug helper, display a localized rating:
		return String.format("Mean(μ)=%f, Std-Dev(σ)=%f", mean, standardDeviation);
	}

	public static double calcMeanMean(Collection<Rating> ratings) {
		double ret = 0;
		for (Rating rating : ratings)
			ret += rating.mean;
		return ret / ratings.size();
	}

	@SuppressWarnings("all")
	public double getConservativeStandardDeviationMultiplier() {
		return this.conservativeStandardDeviationMultiplier;
	}

	@SuppressWarnings("all")
	public double getMean() {
		return this.mean;
	}

	@SuppressWarnings("all")
	public double getStandardDeviation() {
		return this.standardDeviation;
	}

	@SuppressWarnings("all")
	public double getConservativeRating() {
		return this.conservativeRating;
	}

	@Override
	@SuppressWarnings("all")
	public boolean equals(final Object o) {
		if (o == this)
			return true;
		if (!(o instanceof Rating))
			return false;
		final Rating other = (Rating) o;
		if (!other.canEqual((Object) this))
			return false;
		if (Double.compare(this.getConservativeStandardDeviationMultiplier(),
				other.getConservativeStandardDeviationMultiplier()) != 0)
			return false;
		if (Double.compare(this.getMean(), other.getMean()) != 0)
			return false;
		if (Double.compare(this.getStandardDeviation(), other.getStandardDeviation()) != 0)
			return false;
		if (Double.compare(this.getConservativeRating(), other.getConservativeRating()) != 0)
			return false;
		return true;
	}

	@SuppressWarnings("all")
	public boolean canEqual(final Object other) {
		return other instanceof Rating;
	}

	@Override
	@SuppressWarnings("all")
	public int hashCode() {
		final int PRIME = 31;
		int result = 1;
		final long $conservativeStandardDeviationMultiplier = Double.doubleToLongBits(this
				.getConservativeStandardDeviationMultiplier());
		result = result * PRIME
				+ (int) ($conservativeStandardDeviationMultiplier >>> 32 ^ $conservativeStandardDeviationMultiplier);
		final long $mean = Double.doubleToLongBits(this.getMean());
		result = result * PRIME + (int) ($mean >>> 32 ^ $mean);
		final long $standardDeviation = Double.doubleToLongBits(this.getStandardDeviation());
		result = result * PRIME + (int) ($standardDeviation >>> 32 ^ $standardDeviation);
		final long $conservativeRating = Double.doubleToLongBits(this.getConservativeRating());
		result = result * PRIME + (int) ($conservativeRating >>> 32 ^ $conservativeRating);
		return result;
	}
}