package org.um.feri.ears.examples.dynopt.utils

// IEEE CEC 2025 Competition on Dynamic Optimization Problems
// Generated by Generalized Moving Peaks Benchmark
enum class Scenario(val settings: ComparisonSettings) {
    F1(ComparisonSettings(31, 100, 5, 5, 5000, 1, 100)),
    F2(ComparisonSettings(31, 100, 10, 5, 5000, 1, 100)),
    F3(ComparisonSettings(31, 100, 25, 5, 5000, 1, 100)),
    F4(ComparisonSettings(31, 100, 50, 5, 5000, 1, 100)),
    F5(ComparisonSettings(31, 100, 100, 5, 5000, 1, 100)),
    F6(ComparisonSettings(31, 100, 10, 5, 2500, 1, 100)),
    F7(ComparisonSettings(31, 100, 10, 5, 1000, 1, 100)),
    F8(ComparisonSettings(31, 100, 10, 5, 500, 1, 100)),
    F9(ComparisonSettings(31, 100, 10, 10, 5000, 1, 100)),
    F10(ComparisonSettings(31, 100, 10, 20, 5000, 1, 100)),
    F11(ComparisonSettings(31, 100, 10, 5, 5000, 2, 100)),
    F12(ComparisonSettings(31, 100, 10, 5, 5000, 5, 100));
}

data class ComparisonSettings(
    val numRuns: Int,
    val sampleInterval: Int,
    val peaks: Int,
    val dimensions: Int,
    val changeFrequency: Int,
    val shiftSeverity: Int,
    val environments: Int
) {
    val FEs: List<Int>
        get() = buildList {
            add(1)
            addAll((sampleInterval..(changeFrequency * environments) step sampleInterval).flatMap { i ->
                if (i % changeFrequency == 0 && i < changeFrequency * environments) listOf(i, i + 1)
                else listOf(i)
            })
        }
    val envIndexes: List<Int>
        get() = buildList {
            val envIndex = (changeFrequency / sampleInterval) + 1
            addAll(((envIndex - 1)..(envIndex * environments) step envIndex))
        }
}

data class EvalMetrics(val rating: Double, val deviation: Double)

data class AlgorithmPerformance(
    val name: String,
    val evalMetrics: MutableList<EvalMetrics> = mutableListOf()
)